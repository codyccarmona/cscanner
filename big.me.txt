
include
<
cstdio
>

include
<
iostream
>

include
<
cstdlib
>

include
<
cctype
>

include
<
cassert
>

include
<
cstring
>

include
<
algorithm
>

include
<
vector
>

include
"ascii.h"

define
MAXTOK
256

define
ident_key
"ident"

define
str_key
"string"

define
char_key
"char"

define
digit_key
"digit"
int
cur
;
int
peek
;
illegal characer: # on line 5illegal characer: # on line 6illegal characer: # on line 7illegal characer: # on line 8illegal characer: # on line 9illegal characer: # on line 10illegal characer: # on line 11illegal characer: # on line 12illegal characer: # on line 13illegal characer: # on line 15illegal characer: # on line 16illegal characer: # on line 17illegal characer: # on line 18illegal characer: # on line 19illegal characer: - on line 99illegal characer: - on line 99missing " for '(' || i == ')' || i == ',' ||
 on line 137
missing " for '.' || i == ':' || i == ';' ||
 on line 138
missing " for '?' || i == '[' || i == ']' ||      
 on line 139
missing " for '{' || i == '}' || i == '~';
|      
 on line 140
missing " for '&' || i == '|' || i == '+' || i == '-' || i == '=' || i == '<' || i == '>';
 on line 145
missing " for '&' || i == '|' || i == '+' ||
i == '-' || i == '=' || i == '<' || i == '>';
 on line 150
missing " for '^' || i == '%' || i == '*' || 
 == '-' || i == '=' || i == '<' || i == '>';
 on line 151
missing " for '/' || i == '=' || i == '!' || 
 on line 152
missing " for '>' || i == '<';
| i == '!' || 
 on line 153
illegal characer: - on line 163illegal characer: - on line 163illegal characer: - on line 171illegal characer: - on line 172missing " for '_') {
 on line 188
missing " for '_') {
 on line 190
missing " for '\0';
 on line 195
illegal characer: - on line 223illegal characer: - on line 237illegal characer: - on line 237missing " for '\0';
 on line 241
missing " for '\0';
 on line 251
missing " for '=' && !is_single_char_token(cur)) || (is_repeatable_operator(cur) && cur == peek) || (cur == '-' && peek == '>')){
ø on line 258
missing " for '>' || lexeme[0] == '<') && lexeme[0] == lexeme[1] && cur == '='){
&& cur == peek) || (cur == '-' && peek == '>')){
 on line 264
missing " for '\0';       
[0] == '<') && lexeme[0] == lexeme[1] && cur == '='){
 on line 275
int
line_number
=
1
;
std
:
:
vector
<
std
:
:
pair
<
std
:
:
string
,
int
>>
token_count
;
struct
map_sort_comp
{
template
<
typename
T
>
bool
operator
(
)
(
const
T
&
l
,
const
T
&
r
)
const
{
if
(
l
.
second
!=
r
.
second
)
{
return
l
.
second
>
r
.
second
;
}
return
l
.
first
>
r
.
first
;
}
}
;
enum
State
{
START
=
0
,
A
=
1
,
B
=
2
,
C
=
3
,
D
=
4
,
E
=
5
,
F
=
6
,
REJECT
=
EOF
,
}
;
State
move
(
State
s
,
int
i
,
bool
str
)
{
switch
(
s
)
{
case
A
:
if
(
i
==
BACK
)
return
C
;
else
if
(
(
is_schar
(
i
)
&&
i
!=
LF
)
||
(
!
str
&&
i
==
DITTO
)
||
(
str
&&
i
==
QUOTE
)
)
return
B
;
break
;
case
B
:
break
;
case
C
:
if
(
i
==
BACK
||
is_schar
(
i
)
||
i
==
DITTO
||
i
==
QUOTE
||
(
str
&&
i
==
LF
)
)
return
B
;
else
if
(
isoctal
(
i
)
)
return
D
;
break
;
case
D
:
if
(
isoctal
(
i
)
)
return
E
;
break
;
case
E
:
if
(
isoctal
(
i
)
)
return
B
;
break
;
default
:
break
;
}
return
REJECT
;
}
bool
sortvec
(
const
std
:
:
pair
<
std
:
:
string
,
int
>
&
l
,
const
std
:
:
pair
<
std
:
:
string
,
int
>
&
r
)
{
if
(
l
.
second
!=
r
.
second
)
return
l
.
second
>
r
.
second
;
else
{
if
(
l
.
first
.
size
(
)
==
r
.
first
.
size
(
)
)
return
l
.
first
<
r
.
first
;
return
l
.
first
.
size
(
)
>
r
.
first
.
size
(
)
;
}
}
bool
is_accept_state
(
State
state
)
{
return
state
==
State
:
:
B
||
state
==
State
:
:
D
||
state
==
State
:
:
E
;
}
void
advance
(
int
num_advances
=
1
)
{
while
(
num_advances
>
0
)
{
if
(
cur
==
LF
)
line_number
++
;
cur
=
peek
;
if
(
peek
!=
EOF
)
peek
=
std
:
:
fgetc
(
stdin
)
;
num_advances


;
}
}
bool
is_skippable
(
int
i
)
{
return
isspace
(
i
)
&&
(
i
==
LF
||
i
==
TAB
||
i
==
SPACE
)
;
}
int
skip
(
)
{
if
(
is_skippable
(
cur
)
)
{
while
(
is_skippable
(
cur
)
)
advance
(
)
;
}
if
(
iscomment
(
cur
,
peek
)
)
{
if
(
peek
==
FORWARD
)
{
while
(
cur
!=
LF
&&
cur
!=
EOF
&&
cur
!=
BACK
)
advance
(
)
;
if
(
cur
==
LF
)
advance
(
)
;
}
else
{
while
(
(
cur
!=
ASTERICK
||
cur
==
ASTERICK
&&
peek
!=
FORWARD
)
&&
cur
!=
EOF
)
advance
(
)
;
if
(
cur
==
ASTERICK
&&
peek
==
FORWARD
)
advance
(
2
)
;
}
}
if
(
iscomment
(
cur
,
peek
)
||
is_skippable
(
cur
)
)
skip
(
)
;
return
cur
;
}
bool
is_single_char_token
(
int
i
)
{
return
i
==

i
==

i
==

i
==

}
bool
is_repeatable_operator
(
int
i
)
{
return
i
==

}
bool
isoperator
(
int
i
)
{
return
i
==

i
==

i
==

i
==

}
void
print_token_summary
(
)
{
std
:
:
sort
(
token_count
.
begin
(
)
,
token_count
.
end
(
)
,
sortvec
)
;
printf
(
"\n%13s%15s"
,
"token"
,
"count\n"
)
;
printf
(
"--------------------- -----\n"
)
;
for
(
auto
itr
=
token_count
.
begin
(
)
;
itr
!=
token_count
.
end
(
)
;
itr
++
)
{
printf
(
"%21s %5d\n"
,
itr

>
first
.
begin
(
)
,
itr

>
second
)
;
}
}
void
record_token
(
std
:
:
string
key
)
{
auto
itr
=
token_count
.
begin
(
)
;
for
(
;
itr
!=
token_count
.
end
(
)
;
itr
++
)
{
if
(
itr

>
first
==
key
)
{
itr

>
second
++
;
break
;
}
}
if
(
itr
==
token_count
.
end
(
)
)
token_count
.
push_back
(
std
:
:
pair
<
std
:
:
string
,
int
>
(
key
,
1
)
)
;
}
int
scan
(
char
*
lexeme
)
{
int
i
=
0
;
if
(
skip
(
)
==
EOF
)
return
EOF
;
else
if
(
isalpha
(
cur
)
||
cur
==

while
(
isalpha
(
cur
)
||
isdigit
(
cur
)
||
cur
==

lexeme
[
i
++
]
=
cur
;
advance
(
)
;
}
record_token
(
ident_key
)
;
lexeme
[
i
]
=

return
i
;
}
else
{
if
(
cur
==
QUOTE
||
cur
==
DITTO
)
{
State
state
=
A
;
lexeme
[
i
++
]
=
cur
;
advance
(
)
;
if
(
cur
==
QUOTE
)
{
while
(
cur
!=
QUOTE
&&
cur
!=
EOF
&&
state
!=
REJECT
)
{
lexeme
[
i
++
]
=
cur
;
state
=
move
(
state
,
cur
,
false
)
;
advance
(
)
;
}
if
(
cur
==
QUOTE
)
{
record_token
(
char_key
)
;
lexeme
[
i
++
]
=
cur
;
advance
(
)
;
}
else
{
std
:
:
fprintf
(
stderr
,
"missing %c for %s on line %i"
,
QUOTE
,
lexeme
,
line_number
)
;
lexeme
[
0
]
=
0
;
}
}
else
{
while
(
(
cur
!=
DITTO
||
cur
==
DITTO
&&
lexeme
[
i

1
]
==
BACK
)
&&
cur
!=
EOF
&&
state
!=
REJECT
)
{
state
=
move
(
state
,
cur
,
true
)
;
lexeme
[
i
++
]
=
cur
;
advance
(
)
;
if
(
state
==
B
)
state
=
A
;
}
if
(
cur
==
DITTO
)
{
record_token
(
str_key
)
;
lexeme
[
i
++
]
=
cur
;
advance
(
)
;
}
else
{
std
:
:
fprintf
(
stderr
,
"missing %c for %s on line %i\n"
,
DITTO
,
lexeme
,
(
lexeme
[
i

1
]
==
LF
?
line_number

1
:
line_number
)
)
;
lexeme
[
0
]
=
0
;
}
}
lexeme
[
i
]
=

return
i
;
}
else
if
(
isdigit
(
cur
)
)
{
while
(
isdigit
(
cur
)
)
{
lexeme
[
i
++
]
=
cur
;
advance
(
)
;
}
record_token
(
digit_key
)
;
lexeme
[
i
]
=

return
i
;
}
else
if
(
isoperator
(
cur
)
||
is_single_char_token
(
cur
)
)
{
if
(
(
peek
==

while
(
i
<
2
)
{
lexeme
[
i
++
]
=
cur
;
advance
(
)
;
}
if
(
(
lexeme
[
0
]
==

lexeme
[
i
++
]
=
cur
;
advance
(
)
;
}
}
else
{
lexeme
[
i
++
]
=
cur
;
advance
(
)
;
}
record_token
(
std
:
:
string
(
lexeme
,
i
)
)
;
lexeme
[
i
]
=

return
i
;
}
else
{
std
:
:
fprintf
(
stderr
,
"illegal characer: %c on line %i"
,
cur
,
line_number
)
;
lexeme
[
0
]
=
0
;
advance
(
)
;
}
}
return
0
;
}
int
main
(
int
argc
,
char
*
argv
[
]
)
{
char
lexeme
[
MAXTOK
]
;
int
result
;
cur
=
peek
=
std
:
:
fgetc
(
stdin
)
;
if
(
cur
!=
EOF
)
peek
=
std
:
:
fgetc
(
stdin
)
;
while
(
(
result
=
scan
(
lexeme
)
)
!=
EOF
)
{
std
:
:
cout
<<
lexeme
<<
std
:
:
endl
;
}
print_token_summary
(
)
;
return
0
;
}

        token         count
--------------------- -----
                ident   617
                    (   140
                    )   134
                    ;    99
                    :    53
                    }    48
                   ==    45
                    {    44
                    ,    42
                    =    40
                    .    29
                digit    27
                    [    22
                    ]    22
                    >    21
                   !=    20
                   ||    18
                    <    16
                   &&    15
                   ++    14
               string    13
                    &     4
                   <<     2
                    *     2
                   >>     1
                    !     1
                    ?     1
